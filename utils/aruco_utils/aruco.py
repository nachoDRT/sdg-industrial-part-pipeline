import csv
import sys
import numpy as np
import cv2
import os
from PIL import Image
import random

NUM_ID_CANDIDATES = 100
ARUCO_PX_DIMS = 300
BORDER_BITS = 1


class aruco_utils():

    def __init__(self):
        '''
        Class to work with ArUco markers
        Several ArUco dictionaries available: here DICT_6X6_50 is used
        '''

        self._aruco_dict = cv2.aruco.Dictionary_get(cv2.aruco.DICT_6X6_50)

    def generate_markers(self, num_markers, markers_name):
        '''
        Generate markers. Check previous markers already generated by reading
        a '.csv'. Update the '.csv' with IDs already used. Save markers as
        '.png'

        Parameters:

        num_markers: (int) markers to be generated
        '''

        # Extract the ids already used and generate a vector with id candidates
        marker_ids = self._extract_ids()
        id_candiates = np.arange(NUM_ID_CANDIDATES)

        for i in range(num_markers):

            # Extract the values in id_candiates that are not in marker_ids
            difference_ids = np.setdiff1d(id_candiates, marker_ids)
            new_id = difference_ids[0]

            # Create the ArUco marker
            canvas = np.zeros((ARUCO_PX_DIMS, ARUCO_PX_DIMS, 1), dtype="uint8")
            cv2.aruco.drawMarker(self._aruco_dict, new_id,
                                 ARUCO_PX_DIMS, canvas, BORDER_BITS)

            # Add white border (so the detector can detect 4 corners)
            yellow = [255, 255, 255]
            canvas = cv2.copyMakeBorder(
                canvas, 50, 50, 50, 50, cv2.BORDER_CONSTANT, value=yellow)

            # Show and save the marker
            if not os.path.exists(sys.path[0] + '/' + markers_name):
                os.makedirs(sys.path[0] + '/' + markers_name)
            marker_file_name = sys.path[0] + '/' + markers_name + \
                '/' + markers_name + '_Point_' + str(i+1) + '.png'
            cv2.imwrite(marker_file_name, canvas)
            cv2.imshow("ArUCo Marker", canvas)
            cv2.waitKey(0)

            marker_ids.append(new_id)

        self._update_ids(marker_ids, markers_name)

    def detect_markers(self, image, matrix_flag, distortion_flag, display=False):
        '''
        Show graphic info from ArUco Marker

        Parameters:

        - image
        - matrix_flag (Bool): In case camera matrix is available
        - distortion_flag (Bool): In case distortion coefficients are available
        '''

        matrix_coefficients = np.zeros((3, 3))
        distortion_coefficients = np.zeros((1, 5))

        height, width = image.shape[:2]

        # Custom camera matrix
        if matrix_flag:
            matrix_coefficients[0] = [1367.14, 0, 973.89]
            matrix_coefficients[1] = [0, 1368.28, 526.45]
            matrix_coefficients[2] = [0, 0, 1]

        # Custom distortion coefficients
        if distortion_flag:
            distortion_coefficients[0][0] = 0
            distortion_coefficients[0][1] = 0
            distortion_coefficients[0][2] = 0
            distortion_coefficients[0][3] = 0
            distortion_coefficients[0][4] = 0

        # BGR to Gray
        gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

        # Marker detection parameters
        arucoParams = cv2.aruco.DetectorParameters_create()

        # Detection
        if matrix_flag or distortion_flag:
            corners, ids, rejected_img_points = cv2.aruco.detectMarkers(gray, self._aruco_dict, parameters=arucoParams,
                                                                        cameraMatrix=matrix_coefficients, distCoeff=distortion_coefficients)
        else:
            corners, ids, rejected_img_points = cv2.aruco.detectMarkers(
                image, self._aruco_dict, parameters=arucoParams)

        # Determine names for ids
        Point_name = []
        if np.all(ids is not None):
            for i in range(0, len(ids)):
                Point_name.append(self._extract_name(ids[i]))

        # Determine the center and the name of each aruco
        if np.all(ids is not None):
            # Determine centers of each Aruco
            pm = []
            for i in range(0, len(ids)):
                pm_1 = (corners[i][0][0] + corners[i][0][2])/2
                pm_2 = (corners[i][0][1] + corners[i][0][3])/2
                pm.append((pm_1 + pm_2)/2)

        # If there are markers found by detector
        if np.all(ids is not None) and display:
            # Iterate in markers
            rvec = []
            tvec = []
            markerPoints = []
            for i in range(0, len(ids)):
                # Estimate pose of each marker and return the values rvec (rotation) and tvec (translation)
                rvec_tmp, tvec_tmp, markerPoints_tmp = cv2.aruco.estimatePoseSingleMarkers(
                    corners[i], 0.02, matrix_coefficients, distortion_coefficients)
                rvec.append(rvec_tmp)
                tvec.append(tvec_tmp)
                markerPoints.append(markerPoints_tmp)

            # Draw A square around the markers
            cv2.aruco.drawDetectedMarkers(image, corners)
            # Draw Axis
            for i in range(0, len(ids)):
                cv2.aruco.drawAxis(image, matrix_coefficients,
                                   distortion_coefficients, rvec[i], tvec[i], 0.01)
            # Draw Point name
            for i in range(0, len(ids)):
                org = (int(pm[i][0]), int(pm[i][1]))
                name = Point_name[i]
                font = cv2.FONT_HERSHEY_SIMPLEX
                fontScale = 1
                thickness = 2
                image = cv2.putText(
                    image, name, org, font, fontScale, (255, 0, 0), thickness, cv2.LINE_AA)

        if display:
            return corners, ids, Point_name, image
        else:
            return corners, ids, Point_name

    def _extract_ids(self) -> list:
        '''
        Return an array with the IDs in the '.csv'
        '''

        # Open '.csv' for ID tracking
        csv_path = sys.path[0] + '/markers_ids.csv'

        marker_ids = []
        try:
            with open(csv_path, 'r') as csv_file:
                reader = csv.reader(csv_file)
                for i, row in enumerate(reader):
                    if i == 0:
                        # Header
                        pass
                    else:
                        marker_ids.append(int(row[0][0]))
        except NameError:
            print('Marker ID not found')

        return marker_ids

    def _extract_name(self, marker_id):
        '''
        Return an string with the Point vinculated to an IDs in the '.csv'
        '''

        # Open '.csv' for ID tracking
        csv_path = os.path.join(
            # os.getcwd(), 'markers_ids.csv')
            os.getcwd(), 'utils/aruco_utils/markers_ids.csv')
        name = 'NA'
        try:
            with open(csv_path, 'r') as csv_file:
                reader = csv.reader(csv_file)
                for i, row in enumerate(reader):
                    if i == marker_id + 1:
                        full_row = row[0]
                        name = full_row[2:]
        except NameError:
            print('Marker ID not found')

        return name

    def _update_ids(self, marker_ids, markers_name):
        '''
        Update the '.csv' with IDs
        '''

        csv_path = sys.path[0] + '/markers_ids.csv'

        try:
            with open(csv_path) as f:
                lines = sum(1 for line in f)
        except:
            lines = 0

        with open(csv_path, 'a', newline='') as file:
            writer = csv.writer(file)
            if lines == 0:
                writer.writerow(["ID"])
                for i in range(lines, len(marker_ids)):
                    writer.writerow(
                        [str(marker_ids[i]) + ' ' + markers_name + '_Point_' + str(i+1)])
            else:
                for i in range(lines-1, len(marker_ids)):
                    writer.writerow(
                        [str(marker_ids[i]) + ' ' + markers_name +
                         '_Point_' + str(i + 1 - (lines - 1))])

    def white_bg_square(img):
        "return a white-background-color image having the img in exact center"
        size = (max(img.size),)*2
        layer = Image.new('RGB', size, (255, 255, 255))
        layer.paste(img, tuple(
            map(lambda x: (x[0]-x[1])/2, zip(size, img.size))))
        return layer
